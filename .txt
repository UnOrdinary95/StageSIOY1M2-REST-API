[1mdiff --git a/fetch_books.py b/fetch_books.py[m
[1mindex a635cc2..956e11a 100644[m
[1m--- a/fetch_books.py[m
[1m+++ b/fetch_books.py[m
[36m@@ -16,14 +16,21 @@[m [mfrom dotenv import load_dotenv[m
 load_dotenv()[m
 [m
 API_BASE_URL = os.getenv("RANOBEDB_API_URL", "https://ranobedb.org/api/v0")[m
[32m+[m[32mNOVELYA_API_URL = os.getenv("NOVELYA_API_URL", "http://localhost:3000/api")[m
[32m+[m[32mNOVELYA_EMAIL = os.getenv("NOVELYA_EMAIL", "")[m
[32m+[m[32mNOVELYA_PASSWORD = os.getenv("NOVELYA_PASSWORD", "")[m
 OUTPUT_FILE = "books_data.json"[m
 INPUT_FILE = "books.txt"[m
 REQUEST_DELAY = 1.1  # Respecting ~60 requests per minute limit[m
[32m+[m[32mCOVER_DOWNLOAD_TIMEOUT = 30  # Timeout for cover download in seconds[m
 [m
 # Price range in EUR (realistic for light novels)[m
 PRICE_MIN = 7.99[m
 PRICE_MAX = 16.99[m
 [m
[32m+[m[32m# Session for handling cookies[m
[32m+[m[32msession = requests.Session()[m
[32m+[m
 [m
 def extract_book_id(url: str) -> Optional[str]:[m
     """Extract book ID from RanobeDB URL."""[m
[36m@@ -38,7 +45,9 @@[m [mdef fetch_book_details(book_id: str) -> Optional[dict]:[m
         url = f"{API_BASE_URL}/book/{book_id}"[m
         response = requests.get(url, timeout=10)[m
         response.raise_for_status()[m
[31m-        return response.json()[m
[32m+[m[32m        data = response.json()[m
[32m+[m[32m        # RanobeDB wraps the book data in a "book" key[m
[32m+[m[32m        return data.get("book") if "book" in data else data[m
     except requests.RequestException as e:[m
         print(f"Error fetching book {book_id}: {e}")[m
         return None[m
[36m@@ -49,13 +58,18 @@[m [mdef get_english_title(book_data: dict) -> str:[m
     if not book_data:[m
         return "Unknown Title"[m
 [m
[32m+[m[32m    # First try the direct title field (for English books)[m
[32m+[m[32m    title = book_data.get("title")[m
[32m+[m[32m    if title:[m
[32m+[m[32m        return title[m
[32m+[m
     # Try to find English title from titles array[m
     if "titles" in book_data:[m
         for title_entry in book_data["titles"]:[m
             if title_entry.get("lang") == "en":[m
[31m-                return title_entry.get("title", book_data.get("title", "Unknown"))[m
[32m+[m[32m                return title_entry.get("title", "Unknown Title")[m
 [m
[31m-    return book_data.get("title", "Unknown Title")[m
[32m+[m[32m    return book_data.get("title_orig", "Unknown Title")[m
 [m
 [m
 def get_author(book_data: dict) -> str:[m
[36m@@ -68,7 +82,9 @@[m [mdef get_author(book_data: dict) -> str:[m
     if "staff" in first_edition:[m
         for staff_member in first_edition["staff"]:[m
             if staff_member.get("role_type") == "author":[m
[31m-                return staff_member.get("name", "Unknown Author")[m
[32m+[m[32m                # Prefer romaji (romanized) name, fallback to name[m
[32m+[m[32m                author_name = staff_member.get("romaji") or staff_member.get("name", "Unknown Author")[m
[32m+[m[32m                return author_name[m
 [m
     return "Unknown Author"[m
 [m
[36m@@ -97,14 +113,14 @@[m [mdef get_cover_url(book_data: dict) -> str:[m
     # Check main image[m
     if book_data.get("image") and book_data["image"].get("filename"):[m
         filename = book_data["image"]["filename"][m
[31m-        return f"https://cdn.ranobedb.org/covers/{filename}"[m
[32m+[m[32m        return f"https://images.ranobedb.org/{filename}"[m
 [m
     # Check in editions[m
     if "editions" in book_data and book_data["editions"]:[m
         for edition in book_data["editions"]:[m
             if edition.get("image") and edition["image"].get("filename"):[m
                 filename = edition["image"]["filename"][m
[31m-                return f"https://cdn.ranobedb.org/covers/{filename}"[m
[32m+[m[32m                return f"https://images.ranobedb.org/{filename}"[m
 [m
     return ""[m
 [m
[36m@@ -128,6 +144,68 @@[m [mdef get_release_date(book_data: dict) -> str:[m
     return datetime.now().isoformat()[m
 [m
 [m
[32m+[m[32mdef download_cover(cover_url: str, light_novel_id: str) -> bool:[m
[32m+[m[32m    """Download cover image and upload via PATCH request."""[m
[32m+[m[32m    if not cover_url:[m
[32m+[m[32m        return False[m
[32m+[m
[32m+[m[32m    patch_response = None[m
[32m+[m[32m    try:[m
[32m+[m[32m        # Download cover from RanobeDB[m
[32m+[m[32m        response = requests.get(cover_url, timeout=COVER_DOWNLOAD_TIMEOUT)[m
[32m+[m[32m        response.raise_for_status()[m
[32m+[m[41m        [m
[32m+[m[32m        # Prepare multipart form data[m
[32m+[m[32m        files = {"cover": (f"{light_novel_id}.jpg", response.content, "image/jpeg")}[m
[32m+[m[41m        [m
[32m+[m[32m        # Send PATCH request to Novelya API (cookies handled by session)[m
[32m+[m[32m        patch_url = f"{NOVELYA_API_URL}/lightnovels/{light_novel_id}/cover"[m
[32m+[m[32m        patch_response = session.patch(patch_url, files=files, timeout=10)[m
[32m+[m[32m        patch_response.raise_for_status()[m
[32m+[m[41m        [m
[32m+[m[32m        return True[m
[32m+[m[32m    except requests.RequestException as e:[m
[32m+[m[32m        print(f"WARNING - Failed to upload cover for {light_novel_id}: {e}")[m
[32m+[m[32m        if patch_response:[m
[32m+[m[32m            print(f"DEBUG - Response body: {patch_response.text}")[m
[32m+[m[32m        return False[m
[32m+[m
[32m+[m
[32m+[m[32mdef create_light_novel(novel_data: dict) -> Optional[str]:[m
[32m+[m[32m    """Create light novel via POST request. Returns light novel ID on success."""[m
[32m+[m[32m    try:[m
[32m+[m[32m        url = f"{NOVELYA_API_URL}/lightnovels"[m
[32m+[m[32m        response = session.post(url, json=novel_data, timeout=10)[m
[32m+[m[32m        response.raise_for_status()[m
[32m+[m[41m        [m
[32m+[m[32m        created_novel = response.json()[m
[32m+[m[32m        return created_novel.get("_id")[m
[32m+[m[32m    except requests.RequestException as e:[m
[32m+[m[32m        print(f"WARNING - Failed to create light novel: {e}")[m
[32m+[m[32m        return None[m
[32m+[m
[32m+[m
[32m+[m[32mdef login_to_api() -> bool:[m
[32m+[m[32m    """Login to Novelya API and establish session with cookies."""[m
[32m+[m[32m    if not NOVELYA_EMAIL or not NOVELYA_PASSWORD:[m
[32m+[m[32m        print("ERROR - NOVELYA_EMAIL and NOVELYA_PASSWORD not set in .env")[m
[32m+[m[32m        return False[m
[32m+[m[41m    [m
[32m+[m[32m    try:[m
[32m+[m[32m        login_url = f"{NOVELYA_API_URL}/login"[m
[32m+[m[32m        response = session.post([m
[32m+[m[32m            login_url,[m
[32m+[m[32m            json={"email": NOVELYA_EMAIL, "password": NOVELYA_PASSWORD},[m
[32m+[m[32m            timeout=10[m
[32m+[m[32m        )[m
[32m+[m[32m        response.raise_for_status()[m
[32m+[m[32m        print("CHECK - Successfully logged in to Novelya API")[m
[32m+[m[32m        return True[m
[32m+[m[32m    except requests.RequestException as e:[m
[32m+[m[32m        print(f"ERROR - Failed to login: {e}")[m
[32m+[m[32m        return False[m
[32m+[m
[32m+[m
 def generate_price() -> float:[m
     """Generate realistic price for light novel in EUR."""[m
     # Round to .99 for realistic pricing[m
[36m@@ -146,13 +224,14 @@[m [mdef process_book(book_id: str) -> Optional[dict]:[m
 [m
     # 20% chance of being out of stock[m
     in_stock = random.random() > 0.2[m
[32m+[m[41m    [m
[32m+[m[32m    cover_url = get_cover_url(book_data)[m
 [m
     novel = {[m
         "title": get_english_title(book_data),[m
         "author": get_author(book_data),[m
         "price": generate_price(),[m
         "inStock": in_stock,[m
[31m-        "cover": get_cover_url(book_data),[m
         "description": book_data.get("description", "No description available")[[m
             :500[m
         ],  # Limit description[m
[36m@@ -161,7 +240,7 @@[m [mdef process_book(book_id: str) -> Optional[dict]:[m
     }[m
 [m
     print(f"CHECK - {novel['title']}")[m
[31m-    return novel[m
[32m+[m[32m    return {"data": novel, "cover_url": cover_url}[m
 [m
 [m
 def read_book_urls(filename: str) -> list:[m
[36m@@ -171,7 +250,8 @@[m [mdef read_book_urls(filename: str) -> list:[m
         return [][m
 [m
     with open(filename, "r", encoding="utf-8") as f:[m
[31m-        urls = [line.strip() for line in f if line.strip()][m
[32m+[m[32m        # Strip whitespace and newlines, skip empty lines[m
[32m+[m[32m        urls = [line.strip() for line in f.readlines() if line.strip()][m
 [m
     return urls[m
 [m
[36m@@ -179,6 +259,17 @@[m [mdef read_book_urls(filename: str) -> list:[m
 def main():[m
     """Main execution function."""[m
     print("RanobeDB Light Novel Fetcher\n")[m
[32m+[m[41m    [m
[32m+[m[32m    # Check if API configuration is set[m
[32m+[m[32m    upload_to_api = NOVELYA_EMAIL and NOVELYA_PASSWORD[m
[32m+[m[32m    if upload_to_api:[m
[32m+[m[32m        print(f"API Mode: Uploading to {NOVELYA_API_URL}")[m
[32m+[m[32m        if not login_to_api():[m
[32m+[m[32m            print("ERROR - Could not login to API. Switching to Local Mode")[m
[32m+[m[32m            upload_to_api = False[m
[32m+[m[32m    else:[m
[32m+[m[32m        print("Local Mode: Generating JSON file only")[m
[32m+[m[32m    print()[m
 [m
     # Read URLs[m
     urls = read_book_urls(INPUT_FILE)[m
[36m@@ -190,6 +281,9 @@[m [mdef main():[m
 [m
     # Extract book IDs and fetch data[m
     books_data = [][m
[32m+[m[32m    successfully_created = 0[m
[32m+[m[32m    failed_cover_uploads = 0[m
[32m+[m[41m    [m
     for i, url in enumerate(urls, 1):[m
         book_id = extract_book_id(url)[m
 [m
[36m@@ -198,8 +292,28 @@[m [mdef main():[m
             continue[m
 [m
         book = process_book(book_id)[m
[31m-        if book:[m
[31m-            books_data.append(book)[m
[32m+[m[32m        if not book:[m
[32m+[m[32m            continue[m
[32m+[m[41m        [m
[32m+[m[32m        novel_data = book["data"][m
[32m+[m[32m        cover_url = book["cover_url"][m
[32m+[m[41m        [m
[32m+[m[32m        if upload_to_api:[m
[32m+[m[32m            # Create light novel via API[m
[32m+[m[32m            created_id = create_light_novel(novel_data)[m
[32m+[m[32m            if created_id:[m
[32m+[m[32m                books_data.append({**novel_data, "_id": created_id})[m
[32m+[m[32m                successfully_created += 1[m
[32m+[m[41m                [m
[32m+[m[32m                # Upload cover if available (optional, skip on network errors)[m
[32m+[m[32m                if cover_url:[m
[32m+[m[32m                    time.sleep(0.5)  # Wait a bit before uploading cover[m
[32m+[m[32m                    download_cover(cover_url, created_id)[m
[32m+[m[32m            else:[m
[32m+[m[32m                print(f"SKIP - Failed to create: {novel_data['title']}")[m
[32m+[m[32m        else:[m
[32m+[m[32m            # Local mode: just collect data[m
[32m+[m[32m            books_data.append(novel_data)[m
 [m
         # Rate limiting: wait before next request (except last one)[m
         if i < len(urls):[m
[36m@@ -210,10 +324,14 @@[m [mdef main():[m
         with open(OUTPUT_FILE, "w", encoding="utf-8") as f:[m
             json.dump(books_data, f, indent=2, ensure_ascii=False)[m
 [m
[31m-        print(f"\nCHECK - Successfully fetched {len(books_data)}/{len(urls)} books")[m
[32m+[m[32m        print(f"\nCHECK - Successfully processed {len(books_data)}/{len(urls)} books")[m
[32m+[m[32m        if upload_to_api:[m
[32m+[m[32m            print(f"CHECK - Created {successfully_created} light novels in API")[m
[32m+[m[32m            if failed_cover_uploads > 0:[m
[32m+[m[32m                print(f"WARNING - Failed to upload {failed_cover_uploads} covers")[m
         print(f"CHECK - Data saved to '{OUTPUT_FILE}'")[m
     else:[m
[31m-        print("\nERROR - No books were successfully fetched")[m
[32m+[m[32m        print("\nERROR - No books were successfully processed")[m
 [m
 [m
 if __name__ == "__main__":[m
